from qifparser.parser import get_class_def
from qifparser._version import __version__

# def get_cli_class_name(qif_name):
#     cdef = get_class_def(qif_name)
#     return cdef.cxx_name

# TODO: config
common_inc = "<common.h>"


def _gen_src_preamble(f, cls):
    f.write("//\n")
    f.write(f"// Auto-generated by qifparser {__version__}. Don't edit.\n")
    f.write("//\n")
    f.write("\n")
    f.write(f"#include {common_inc}\n")
    f.write("\n")


def _gen_src_class_loader(f, cls):
    # cxx_clsobj_name = f"sClassObj_{qifname}"
    # cxx_clscls_name = f"LSpecificClass_{qifname}"
    cxx_wp_clsname = cls.get_wp_clsname()
    cxx_cli_clsname = cls.cxx_name

    f.write("\n")
    f.write(f"SINGLETON_BASE_IMPL({cxx_wp_clsname});\n")
    f.write("\n")

    if cls.is_cloneable():
        f.write("MC_CLONEABLE_IMPL({cxx_cli_clsname});\n")
        f.write("\n")

    f.write(f"MC_DYNCLASS_IMPL2({cxx_cli_clsname}, {cxx_wp_clsname});\n")
    f.write(f"MC_PROP_IMPL2({cxx_cli_clsname}, {cxx_wp_clsname});\n")
    f.write(f"MC_INVOKE_IMPL2({cxx_cli_clsname}, {cxx_wp_clsname});\n")
    f.write("\n")


def _gen_cxx_src_impl(f, target, output_path):
    qif_name = target.qifname
    cls = get_class_def(qif_name)
    cxx_cli_clsname = cls.cxx_name
    cxx_wp_clsname = cls.get_wp_clsname()
    print(f"generating C++ wrapper ({cxx_cli_clsname}) src for {qif_name}")

    if cls.is_smart_ptr():
        cxx_cli_clsname = f"qlib::LScrSp<{cxx_cli_clsname}>"

    _gen_src_preamble(f, cls)

    if cls.input_rel_path is not None:
        cxx_wp_incname = cls.input_rel_path.parent / f"{qif_name}_wrap.hpp"
        f.write(f'#include "{cxx_wp_incname}"\n')

    f.write("\n")
    f.write("#include <qlib/ClassRegistry.hpp>\n")
    f.write("#include <qlib/LVariant.hpp>\n")
    # f.write("#include <qlib/LPropEvent.hpp>\n")
    f.write("\n")

    # TODO: impl?? (not used in current qif)
    # foreach my $f (@Parser::user_cxx_incfiles) {
    #   print $fhout "\#include $f\n";
    # }

    # TODO: impl referenced wrapper hdrs
    # if ($cls && $cls->{"refers"}) {
    #     foreach my $icls (@{$cls->{"refers"}}) {
    #         my $hdrname = qif2WpHdrFname($icls);
    #         print $fhout "#include \"$hdrname\"\n";
    #     }
    #     print $fhout "\n";
    # }

    f.write("\n")
    f.write("using qlib::LString;\n")
    f.write("using qlib::LVariant;\n")
    f.write("using qlib::LVarArgs;\n")
    f.write("using qlib::LClass;\n")
    f.write("using qlib::ClassRegistry;\n")
    f.write("\n")
    f.write(f"// XXX {cxx_wp_clsname}\n")

    f.write("/////////////////////////////////////\n")
    f.write(f"// Class loader code for the client class {cxx_cli_clsname}\n")
    _gen_src_class_loader(f, cls)
    f.write("\n")

    f.write("/////////////////////////////////////\n")
    f.write("//\n")
    f.write(f"// Wrapper class for {cxx_cli_clsname}\n")
    f.write("//\n")
    f.write("\n")


def gen_cxx_source(target, output_path):
    output_path.parent.mkdir(exist_ok=True, parents=True)
    with output_path.open("w") as f:
        try:
            _gen_cxx_src_impl(f, target, output_path)
        except Exception:
            if output_path.is_file():
                output_path.unlink()
            raise
    print(f"Wrote file: {output_path}")
